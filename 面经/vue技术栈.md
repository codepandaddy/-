# v-if和v-for哪个优先级更高

- 首先，实践中不能把他俩放在同一个元素上，因为在循环里都会有个列表渲染函数，如果有if则会出现在渲染函数中，导致每次都要在渲染函数中判断一遍
  - 为了避免这种情况，可以先过滤数组，用计算属性computed处理，或者用template标签（类似将if判断放在渲染函数调用前）
- 其次，vue2中v-for优先级更高，哪怕只渲染某部分列表，也会遍历整个列表
- vue3中v-if优先级更高，如果调用变量不存在则抛出异常

# vue2和vue3的区别

## 双向绑定原理（响应式原理）

- 首先，该原理定义是：能够使数据变化可以被检测并对这种变化做出响应，同时绑定到视图，也即是MVVM框架的核心，数据驱动应用，有利于前后端分离
- 通过响应式加上虚拟dom和patch算法，不需要关注dom操作，减少开发难度


- vue2用的是Object.defineProperty做数据拦截，每个属性都有get、set方法，需要借助api深度监听
  - 初始化时递归遍历造成性能损失，增删需要用户使用vue.set和delete等特殊api才能生效，否则对象定义的新属性、数组操作监听不到
  - 同时不支持es6的set和map
- vue3用proxy，也实现数据拦截，优化block，tree，solt，diff，不需要特殊api就能监听，响应式被抽取为reactivity包支持第三方扩展使用
  - 不兼容ie

## 声明周期

- vue3大部分生命周期在vue2的周期前加 on 即可
- 但vue3没有beforeCreate 和 created两个周期，可以在setup中自己定义一个

## 组件传值props和emit

- Vue2中是 props和 this.$emit 
- Vue3中则是[defineEmits defineProps] props emit，或引入mitt

## 选项式api和组合式api

- Vue2中 选项式的api，创建组件时需要使用各种选项 data methods  watch等
- Vue3组合式允许将相关的代码逻辑放在一起处理，让代码更易于理解和维护
  - setup函数为组件设置初始值，如响应式数据、计算属性、方法等
  - ref与reactive
  - computed与watch

## mixins和hooks

- 都可以实现一段代码多页面复用的效果
- Vue 2 中，Mixins 是一种全局特性，可以在多个组件之间共享代码。你可以创建一个 Mixin 对象，然后在组件中通过 Mixins 选项引入这个对象，从而将 Mixin 中的属性和方法合并到组件中
  - 如果多个 Mixins 中有相同的属性或方法，可能会导致命名冲突
  - 隐式引入变量，无法定位变量的位置，不知道在父组件里还是mixins里，多个mixins就更难找了
  - 如果mixins里有很多代码，但父组件只用一段，就会增加无效代码的引用
- Vue3的Hooks允许你将相关的逻辑组合到一起，形成一个逻辑单元
  - `hooks`中引入的变量通过`hooks 名.变量名`的方式进行使用，从而避免了变量重名的问题

## 根标签

- vue2必须有，vue3自带一个根标签叫做Fragment，可以节省空间，提高效率

# vue3响应式原理

- 根本实现原理，就是对基本操作的拦截，读取和设置，读取的时候就把副作用函数存到“桶”里面，设置的时候就拿出来执行
- 接着用weekmap来实现对响应式数据和副作用函数建立联系，当没有引用关系的时候就会回收掉
- 解决了一些问题
  - 分支切换导致的冗余副作用
  - 嵌套的副作用--执行结束后弹出栈
  - 避免无限递归循环--在没执行完之前不修改activeEffect
  - 调度执行schedule--可以控制执行副作用函数的时机、次数、方式
    - 用于computed懒执行（手动执行）和watch的immediate（非立即执行则放到异步的微任务队列中）
  - 竞态问题--标记过期

# pinia和vuex

- Pinia 不仅提供了一个更简单的 API，也提供了符合组合式 API 风格的 API，最重要的是，搭配 TypeScript 一起使用时有非常可靠的类型推断支持


- *mutations* 不再存在。他们经常被认为是 **非常 冗长**。他们最初带来了 devtools 集成，但这不再是问题。
  - devtools用来捕捉mutation的快照，但无法获取异步的
- 无需要创建自定义的复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断
- 不再需要注入、导入函数、调用函数、享受自动完成功能
- 无需动态添加 Store，默认情况下它们都是动态的、自动的，也仍然可以随时手动使用 Store 进行注册
- 不存在module的概念，而是store的概念，每个store就是一个状态管理单元
  - 不再有 *modules* 的嵌套结构。仍然可以通过在另一个 Store 中导入和 *使用* 来隐式嵌套 Store，但 Pinia 提供平面结构，同时仍然支持 Store 之间的交叉组合方式。 **甚至可以拥有 Store 的循环依赖关系**
- 没有 *命名空间模块*。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，您可以说所有 Store 都是命名空间的
  - 可以创建多个store，他们之间相互独立

# 组件通信

## 父子组件

- props/emits/parent/ref/attrs

## 兄弟组件

- parent/root/eventbus/vuex

## 跨层级

- eventbus/vuex/provide+inject

# vue中如何扩展一个组件

## 逻辑扩展

- mixins
  - 分发vue组件中可复用的功能
  - 混入对象的选项将被混入该组件本身的选项
- extends
  - 比如继承loading组件并挂载到body中的div上，将控制loading显隐的方法挂载到vue原型上
- composition api
  - vue3中的hooks，混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，此方法可以解决

## 内容扩展

- slots
  - 可以精确分发，用具名插槽；要使用子组件中的数据可以使用作用域插槽

# 子组件可以直接改变父组件的数据么

- 所有的 prop 都使得其父子之间形成了一个单向下行绑定
- 这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解
- emit一个事件让父组件去做这个变更
- 用$parent违反了单向数据流原则

# 虚拟dom

- 本身就是js对象，通过不同的属性描述视图结构
- 好处：将真实的元素节点抽象为VNode，减少直接操作dom的次数，提高性能，实现跨平台
- how：template模板被编译器compiler编译为渲染函数，在mount过程中调用render函数，返回虚拟dom对象，但还不是真的dom，在后续的patch过程中进一步转化为dom
- diff应用：更新流程，响应式数据变化，将组件重新render，生成新的vdom，通过diff找到变化并转换为最小量的dom操作，高效更新视图

# diff算法

- 又称patching算法，虚拟dom转换为真实dom
- vue2为了降低watcher的粒度，每个组件只有一个watcher，需要引入patching算法才能精确找到发生变化的地方并高效更新
- when：组件内响应式数据变更触发实例执行其更新函数时，更新函数重新执行render，获得最新的vdom，再执行patch，传入新旧vdom，对比找到变化，最后转换为真实dom
- how：patch是一个递归过程，遵循深度优先，同层比较策略

## vue2和vue3的区别

- vue2的diff算法对比的颗粒度是组件，需要遍历整个dom树，但其实有静态节点
- vue3添加了静态标记、静态提升和事件缓存，序列化为字符串，减少编译和渲染成本


- 前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表
  - 比如我会配置一个asyncRoutes数组，需要认证的页面在其路由的meta中添加一个roles字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。
  - 此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过router.addRoutes(accessRoutes)方式动态添加路由即可。
- 后端方案会把所有页面路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过addRoutes动态添加路由信息
- 按钮权限的控制通常会实现一个指令，例如v-permission，将按钮要求角色通过值传给v-permission指令，在指令的moutned钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮