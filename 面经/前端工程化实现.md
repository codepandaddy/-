# axios的二次封装

## axios是什么

- axios是一个轻量的http客户端

- 基于XMLHttpRequest服务来执行HTTP请求，支持丰富的配置，支持Promise、浏览器和node.js端

  - ```js
    var defaults.adapter = getDefaultAdapter();
    function getDefaultAdapter () {
    	var adapter;
        if (typeof XMLHttpRequest !== 'undefined') {
        	// 浏览器环境发送xhr
            adapter = require('./adapter/xhr');
        } else if (typeof process !== 'undefined') {
        	// node环境发送http
            adapter = require('./adapter/http');
        }
       return adapter;
    }
    ```

- 支持请求/响应拦截器，可以批量发送多个请求

## axios相比原生ajax的优点

ajax的缺点

- 本身是针对MVC的编程,不符合现在前端MVVM的浪潮
- 基于原生的XHR开发，XHR本身的架构不清晰。
- JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）
- 不符合关注分离（Separation of Concerns）的原则
- 配置和调用方式非常混乱，而且基于事件的异步模型不友好。

## axios相关配置属性

- url用于请求的服务器url
- method是创建请求时使用的方法，默认是get
- baseURL将自动添加在url前面，除非url是绝对的
- transformRequest允许在向服务器发送前，修改请求数据，只能用put、post、patch请求
- headers请求头
- params请求参数，必须是无格式对象plainobject或者urlsearchparams对象
- auth表示使用http基础验证，提供authorization头，会覆盖headers中的authorization
- proxy定义代理服务器主机的名称和端口，其中的auth表示连接代理的基础验证，会覆盖掉proxy-authorization头，覆盖headers中的proxy-authorization

## axios常用语法

- **axios(config): 通用/最本质的发任意类型请求的方式**
- **axios(url[, config]): 可以只指定 url 发 get 请求**
- **axios.request(config): 等同于 axios(config)**
- **axios.get(url[, config]): 发 get 请求**
- **axios.delete(url[, config]): 发 delete 请求**
- **axios.post(url[, data, config]): 发 post 请求**
- **axios.put(url[, data, config]): 发 put 请求**
- axios.defaults.xxx: 请求的默认全局配置
- axios.interceptors.request.use(): 添加请求拦截器
- axios.interceptors.response.use(): 添加响应拦截器
- axios.create([config]): 创建一个新的 axios(它没有下面的功能)
- axios.Cancel(): 用于创建取消请求的错误对象
- axios.CancelToken(): 用于创建取消请求的 token 对象
- axios.isCancel(): 是否是一个取消请求的错误
- **axios.all(promises): 用于批量执行多个异步请求**
- axios.spread(): 用来指定接收所有成功数据的回调函数的方法

## 为什么要二次封装

- 每次请求都需要把这些请求处理权限控制、超时时间、请求头、错误处理、加密处理等等
- 因此二次封装可以用拦截器对请求和响应统一处理，一是可以减少代码冗余、api集中管理，二是能实现安全性控制

## 怎么封装

(以下为个人的项目经验，酌情考量)

- 先跟后端约定好请求时间、请求头和加解密方式等等

- 接着，根据vuex封装异步请求的一些信息，包括系统的信息（时间差）、应用的信息（xsrftoken、移动端请求头）等（配合vue-router在main.js中全局前置路由中拦截用户token）

- 随后便在api包下创建server.js文件，引入axios，设置异步请求头

- ```js
  import axios from 'axios';
  axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
  ```

- 创建server类，将引入sm加密算法用到的加解密工具以及配置项文件，作为其属性，同时创建两个内部函数，request和axios，axios为二次封装主函数，request是对外函数，api请求使用

```js
import config from '@/configure';
import { Toast } from 'vant';
import {logout} from '@/plugins/logout';
import encryptTool from '@/utils/encryptTool';// 用到了sm-crypto国密工具库及其他加解密工具
export default class Server {
  constructor() {
    this.encrypt = encryptTool;
    this.config = config;
  }
  // 供各组件api使用
  request(method,url,params) {
    return new Promise((resolve,reject) => {
      this.axios(method,url,params).then(data => resolve(dava)).catch(error => reject(error));
    });
  }
  /**
   * axios请求封装
   * @param {*} method 请求方式
   * @param {*} url 请求地址
   * @param {*} params 请求参数
   * @returns 返回结果
   */
  axios(method, url, params) {
      // 返回promise对象
      return new Promise((resolve,reject) => {
        // 初始化ajax参数
        const _option = {
          method,
          url,
          data: null,
          // params: null, // 由于项目不涉及get请求，此除省略
          headers: null,
          timeout: 60*1000, // 请求超时为60秒
          responseType: null, // 为空，根据content-type来确定响应类型
          withCredentials: false // 不允许跨域请求，一般单点登录需要设置为true
        };
        // 开始处理请求头
        typeof params !== 'object' && (params = {});
        !params.headers && (params.headers = {});
        // 防止csrf攻击（跨域请求伪造），对认证过的站点进行二次认证
        if (config.csrfToken !== false) { 
          // 获取应用信息
          const baseInfo = store?.state?.app?.baseInfo || {};
          params.headers['X-XSRF-TOKEN'] = baseInfo.csrfToken || '';
        }
        // 获取用户token信息
        const token = store?.state?.user?.token || '';
        if (token) {
          params.headers['u-token'] = token;
        }
        // 避免浏览器对url缓存，每次都是新的请求
        const enable = config.enableSysInfo || !Object.prototype.hasOwnProperty.call(config, 'enableSysInfo');
        // hash值
        let hash = '';
        if (enable && store?.state?.sys) {
          // 获取系统时间
          const time = new Date().getTime() + (store.state.sys.timeDiffer || 0);
          params.headers['XX-Time'] = time.toString();
          // 生成hash值，同时用于sm计算比对
          const randomStr = encryptTool.getRandomKey();
          hash = randomStr + sha256(randomStr + time);
          params.headers['XX-Key'] = hash;
        }
        // 判断是否加密
        const encrypted = config.encrypt.isEncrypted;
        if (encrypted && !params.headers['content-type']) {
          params.headers['content-type'] = this.isObject(params.data) ? 'application/json;charset=UTF-8' : 'application/x-www-form-urlencoded';
        }
        
        const key = encryptTool.getRandomKey(32);
        if (encrypted) {
          // sm2生成一个私钥传递给后台
          params.headers['XXX-Key'] = this.getCipherKey(key);
          if (params.data) {
          	// sm3生成密文，后端用来判断数据的完整性
            params.headers['XXX-Crc'] = this.getCipherCrc(this.convertToStr(params.data) + hash);
            // sm4生成密文，后端根据私钥和sm4解密获取数据
            params.data = this.getParamsData(key, params);
          }
        }
        // 添加移动端header
        Object.assign(params.headers, store.state.app.microAppHeader || {});
        Object.assign(_option, params);
        // 开始请求数据
        axios.request(_option).then(res => {
          if (res.data && res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') !== -1) {
            // 是否需要解密，需要则用私钥和sm4解密获取
           	encrypted ? (res.data = this.getResData(key, res.data)) : (res.data = this.isObject(res.data) ? res.data : JSON.parse(res.data));
            resolve(this.isObject(res.data) ? res.data : JSON.parse(res.data));
          }
        }).catch(async err => {
          if (err?.code === '??') {
			Toast('请求超时，请切换网络重试');
          }
          if (err.response && err.response.status === 401) {
            // token置空
            await store.commit('SETTOKEN', '');
            Toast('登录超时，请重新登录');
            // await router.replace({name:'login'});
            logout();
            return;
          }
          if (err) {
            Toast('系统出错了，请联系管理员');
            reject(err);
            return;
          }
          reject(err);
        });
    });
  }
  
  // 获取sm2密钥
  getCipherKey(key) {
    return encryptTool.SM2Encrypt(key);
  }
  
  // 获取sm3密钥
  getCipherCrc(data) {
    return encryptTool.SM3Encrypt(data);
  }
  
  // 获取sm4密文
  getParamsData(key, params) {
    return encryptTool.SM4Encrypt(this.convertToStr(params.data), key);
  }
  
  // sm4解密
  getResData(key, data) {
    return encryptTool.SM4Decrypt(data.data, key);
  }

  // 转换为json串
  convertToStr(data) {
    return this.isObject(data) ? JSON.stringify(data) : data;
  }
	
  // 判断是否为对象
  isObject(data) {
    return !data || Object.prototype.toString.call(data) === '[object Object]' || Object.prototype.toString.call(data) === '[object Array]';
  }
}
```

- 可以看出，重要的部分是
  - 防csrf攻击
  - 避免url缓存
  - sm加解密
  - 处理请求异常的情况

# 用sm对前端字典加解密

- 封装localstorage，生成私钥，并用其对value值进行加解密

```js
let encryptKey;
function setItem(key, content, isEncrypted) {
  if (!isEncrypted) {
    localStorage.setItem(key, content);
    return;
  }
  if (!encryptKey) {
    encryptKey = encrypt.getRandomKey(32);
  }
  localStorage.setItem(key, encrypt.SM4Encrypt(content, encryptKey));
}
function getItem(key, isEncrypted) {
  if (!isEncrypted) {
    return localStorage.getItem(key);
  }
  if (!encryptKey) {
    return null;
  }
  return encrypt.SM4Decrypt(localStorage.getItem(key), encryptKey);
}
export default {
  setItem,
  getItem
}
```

