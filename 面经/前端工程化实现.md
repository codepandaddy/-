# axios的二次封装

## axios是什么

- axios是一个轻量的http客户端
- 基于XMLHttpRequest服务来执行HTTP请求，支持丰富的配置，支持Promise、浏览器和node.js端

## 为什么要二次封装

- 每次请求都需要把这些请求处理权限控制、超时时间、请求头、错误处理、加密处理等等
- 因此二次封装可以用拦截器对请求和响应统一处理，一是可以减少代码冗余、api集中管理，二是能实现安全性控制

## 怎么封装

(以下为个人的项目经验，酌情考量)

- 先跟后端约定好请求时间、请求头和加解密方式等等

- 接着，根据vuex封装异步请求的一些信息，包括系统的信息（时间差）、应用的信息（xsrftoken、移动端请求头）等（配合vue-router在main.js中全局前置路由中拦截用户token）

- 随后便在api包下创建server.js文件，引入axios，设置异步请求头

- ```js
  import axios from 'axios';
  axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
  ```

- 创建server类，将引入sm加密算法用到的加解密工具以及配置项文件，作为其属性，同时创建两个内部函数，request和axios，axios为二次封装主函数，request是对外函数，api请求使用

```js
import config from '@/configure';
import { Toast } from 'vant';
import {logout} from '@/plugins/logout';
import encryptTool from '@/utils/encryptTool';// 用到了sm-crypto国密工具库及其他加解密工具
export default class Server {
  constructor() {
    this.encrypt = encryptTool;
    this.config = config;
  }
  // 供各组件api使用
  request(method,url,params) {
    return new Promise((resolve,reject) => {
      this.axios(method,url,params).then(data => resolve(dava)).catch(error => reject(error));
    });
  }
  /**
   * axios请求封装
   * @param {*} method 请求方式
   * @param {*} url 请求地址
   * @param {*} params 请求参数
   * @returns 返回结果
   */
  axios(method, url, params) {
      // 返回promise对象
      return new Promise((resolve,reject) => {
        // 初始化ajax参数
        const _option = {
          method,
          url,
          data: null,
          // params: null, // 由于项目不涉及get请求，此除省略
          headers: null,
          timeout: 60*1000, // 请求超时为60秒
          responseType: null, // 为空，根据content-type来确定响应类型
          withCredentials: false // 不允许跨域请求，一般单点登录需要设置为true
        };
        // 开始处理请求头
        typeof params !== 'object' && (params = {});
        !params.headers && (params.headers = {});
        // 防止csrf攻击（跨域请求伪造），对认证过的站点进行二次认证
        if (config.csrfToken !== false) { 
          // 获取应用信息
          const baseInfo = store?.state?.app?.baseInfo || {};
          params.headers['X-XSRF-TOKEN'] = baseInfo.csrfToken || '';
        }
        // 获取用户token信息
        const token = store?.state?.user?.token || '';
        if (token) {
          params.headers['u-token'] = token;
        }
        // 避免浏览器对url缓存，每次都是新的请求
        const enable = config.enableSysInfo || !Object.prototype.hasOwnProperty.call(config, 'enableSysInfo');
        // hash值
        let hash = '';
        if (enable && store?.state?.sys) {
          // 获取系统时间
          const time = new Date().getTime() + (store.state.sys.timeDiffer || 0);
          params.headers['XX-Time'] = time.toString();
          // 生成hash值，同时用于sm计算比对
          const randomStr = encryptTool.getRandomKey();
          hash = randomStr + sha256(randomStr + time);
          params.headers['XX-Key'] = hash;
        }
        // 判断是否加密
        const encrypted = config.encrypt.isEncrypted;
        if (encrypted && !params.headers['content-type']) {
          params.headers['content-type'] = this.isObject(params.data) ? 'application/json;charset=UTF-8' : 'application/x-www-form-urlencoded';
        }
        
        const key = encryptTool.getRandomKey(32);
        if (encrypted) {
          // sm2生成一个私钥传递给后台
          params.headers['XXX-Key'] = this.getCipherKey(key);
          if (params.data) {
          	// sm3生成密文，后端用来判断数据的完整性
            params.headers['XXX-Crc'] = this.getCipherCrc(this.convertToStr(params.data) + hash);
            // sm4生成密文，后端根据私钥和sm4解密获取数据
            params.data = this.getParamsData(key, params);
          }
        }
        // 添加移动端header
        Object.assign(params.headers, store.state.app.microAppHeader || {});
        Object.assign(_option, params);
        // 开始请求数据
        axios.request(_option).then(res => {
          if (res.data && res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') !== -1) {
            // 是否需要解密，需要则用私钥和sm4解密获取
           	encrypted ? (res.data = this.getResData(key, res.data)) : (res.data = this.isObject(res.data) ? res.data : JSON.parse(res.data));
            resolve(this.isObject(res.data) ? res.data : JSON.parse(res.data));
          }
        }).catch(async err => {
          if (err?.code === '??') {
			Toast('请求超时，请切换网络重试');
          }
          if (err.response && err.response.status === 401) {
            // token置空
            await store.commit('SETTOKEN', '');
            Toast('登录超时，请重新登录');
            // await router.replace({name:'login'});
            logout();
            return;
          }
          if (err) {
            Toast('系统出错了，请联系管理员');
            reject(err);
            return;
          }
          reject(err);
        });
    });
  }
  
  // 获取sm2密钥
  getCipherKey(key) {
    return encryptTool.SM2Encrypt(key);
  }
  
  // 获取sm3密钥
  getCipherCrc(data) {
    return encryptTool.SM3Encrypt(data);
  }
  
  // 获取sm4密文
  getParamsData(key, params) {
    return encryptTool.SM4Encrypt(this.convertToStr(params.data), key);
  }
  
  // sm4解密
  getResData(key, data) {
    return encryptTool.SM4Decrypt(data.data, key);
  }

  // 转换为json串
  convertToStr(data) {
    return this.isObject(data) ? JSON.stringify(data) : data;
  }
	
  // 判断是否为对象
  isObject(data) {
    return !data || Object.prototype.toString.call(data) === '[object Object]' || Object.prototype.toString.call(data) === '[object Array]';
  }
}
```

- 可以看出，重要的部分是
  - 防csrf攻击
  - 避免url缓存
  - sm加解密
  - 处理请求异常的情况

# 用sm对前端字典加解密

- 封装localstorage，生成私钥，并用其对value值进行加解密

```js
let encryptKey;
function setItem(key, content, isEncrypted) {
  if (!isEncrypted) {
    localStorage.setItem(key, content);
    return;
  }
  if (!encryptKey) {
    encryptKey = encrypt.getRandomKey(32);
  }
  localStorage.setItem(key, encrypt.SM4Encrypt(content, encryptKey));
}
function getItem(key, isEncrypted) {
  if (!isEncrypted) {
    return localStorage.getItem(key);
  }
  if (!encryptKey) {
    return null;
  }
  return encrypt.SM4Decrypt(localStorage.getItem(key), encryptKey);
}
export default {
  setItem,
  getItem
}
```

