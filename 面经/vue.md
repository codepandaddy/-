# v-if和v-for哪个优先级更高

- 首先，实践中不能把他俩放在同一个元素上，因为在循环里都会有个列表渲染函数，如果有if则会出现在渲染函数中，导致每次都要在渲染函数中判断一遍
  - 为了避免这种情况，可以先过滤数组，用计算属性computed处理，或者用template标签（类似将if判断放在渲染函数调用前）
- 其次，vue2中v-for优先级更高，哪怕只渲染某部分列表，也会遍历整个列表
- vue3中v-if优先级更高，如果调用变量不存在则抛出异常

# vue2和vue3的区别

## 双向绑定原理（响应式原理）

- 首先，该原理定义是：能够使数据变化可以被检测并对这种变化做出响应，同时绑定到视图，也即是MVVM框架的核心，数据驱动应用，有利于前后端分离
- 通过响应式加上虚拟dom和patch算法，不需要关注dom操作，减少开发难度


- vue2用的是Object.defineProperty做数据拦截，每个属性都有get、set方法，需要借助api深度监听
  - 初始化时递归遍历造成性能损失，增删需要用户使用vue.set和delete等特殊api才能生效，否则对象定义的新属性、数组操作监听不到
  - 同时不支持es6的set和map
- vue3用proxy，也实现数据拦截，优化block，tree，solt，diff，不需要特殊api就能监听，响应式被抽取为reactivity包支持第三方扩展使用
  - 不兼容ie

# vue3响应式原理

- 根本实现原理，就是对基本操作的拦截，读取和设置，读取的时候就把副作用函数存到“桶”里面，设置的时候就拿出来执行
- 接着用weekmap来实现对响应式数据和副作用函数建立联系，当没有引用关系的时候就会回收掉
- 解决了一些问题
  - 分支切换导致的冗余副作用
  - 嵌套的副作用--执行结束后弹出栈
  - 避免无限递归循环--在没执行完之前不修改activeEffect
  - 调度执行schedule--可以控制执行副作用函数的时机、次数、方式
    - 用于computed懒执行（手动执行）和watch的immediate（非立即执行则放到异步的微任务队列中）
  - 竞态问题--标记过期
